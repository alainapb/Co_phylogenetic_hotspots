} else {
########
# If bootstrapping not performed
conf<-matrix(NA,2,2)
signal.strength<-data.frame(cbind(conf[1,],c(d1,d2),conf[2,]))
rownames(signal.strength)<-c("d1","d2")
colnames(signal.strength)<-c("booted lower CI 95%","estimate","booted upper CI 95%")
output<-list(MSE=MSEs,signal.strength=signal.strength,coefficients=data.frame(coefs),CI.boot=NULL,variates=data.frame(data.vecs),predicted=predicted,residuals=residuals,bootvalues=NULL,phylocovs=phylocovs)
class(output)<-"pblm"
return(output)
}
}
o <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=TRUE, maxit=1000, nreps=20)
source("pblm.R") ## modified version of the code in the package 'picante'
o <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=TRUE, maxit=1000, nreps=20)
ht<-vcv(primate_tree, corr=T)
pt<-vcv(primate_para_tree, corr=T)
Y<-table(primate_ndata$Host.species, primate_ndata$Parasite.species, primate_ndata$presence)[,,2]>0
## change names to match the phylogeny
rownames(Y) <- gsub(" ", "_", rownames(Y))
colnames(Y) <- gsub(" ", "_", colnames(Y))
## reorder A matrices so match row/columns of Y
hi<-match(rownames(Y), rownames(ht))
pi<-match(colnames(Y), rownames(pt))
ht<-ht[hi,hi]
pt<-pt[pi,pi]
source("pblm.R") ## modified version of the code in the package 'picante'
o <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=TRUE, maxit=1000, nreps=20)
o$signal.strength
A<-as.matrix(as.vector(as.matrix(assocs)))
data.vecs<-A
#numbers of species and interactions
nassocs<-length(A)
nspp1<-dim(assocs)[1]
nspp2<-dim(assocs)[2]
sppnames1<-rownames(assocs)
sppnames2<-colnames(assocs)
#make names of species pairs
pairnames=NULL  # make a vector of pairwise comparison names
for (o in 1:(nspp2))
{
for (u in 1:nspp1)
{
pairnames<-c(pairnames,paste(sppnames2[o],sppnames1[u],sep="-"))
}
}
U<-rep(1,length(A))
data.vecs<-data.frame(A)
rownames(data.vecs)<-pairnames
astar<-solve((t(U)%*%U),(t(U)%*%A))
MSETotal<-cov(A)
system.time(chol2inv((t(U)%*%U)))
system.time(m1 = chol2inv((t(U)%*%U)))
tin <- Sys.time()
m1 <- chol2inv((t(U)%*%U))
tout <- Sys.time()
tin2 <- Sys.time()
m2 <- qr.solve((t(U)%*%U))
tout2 <- Sys.time()
tin
tout - tin
tout2-tin2
ht<-vcv(primate_tree, corr=T)
pt<-vcv(primate_para_tree, corr=T)
Y<-table(primate_ndata$Host.species, primate_ndata$Parasite.species, primate_ndata$presence)[,,2]>0
## change names to match the phylogeny
rownames(Y) <- gsub(" ", "_", rownames(Y))
colnames(Y) <- gsub(" ", "_", colnames(Y))
## reorder A matrices so match row/columns of Y
hi<-match(rownames(Y), rownames(ht))
pi<-match(colnames(Y), rownames(pt))
ht<-ht[hi,hi]
pt<-pt[pi,pi]
source("pblm.R") ## modified version of the code in the package 'picante'
o <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=FALSE, maxit=1000, method="chol2inv")
o2 <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=FALSE, maxit=1000, method="qr.solve")
o2$signal.strength
o$signal.strength
o$coefficients
o2$coefficients
A<-as.matrix(as.vector(as.matrix(assocs)))
data.vecs<-A
#numbers of species and interactions
nassocs<-length(A)
nspp1<-dim(assocs)[1]
nspp2<-dim(assocs)[2]
sppnames1<-rownames(assocs)
sppnames2<-colnames(assocs)
#make names of species pairs
pairnames=NULL  # make a vector of pairwise comparison names
for (o in 1:(nspp2))
{
for (u in 1:nspp1)
{
pairnames<-c(pairnames,paste(sppnames2[o],sppnames1[u],sep="-"))
}
}
U<-rep(1,length(A))
data.vecs<-data.frame(A)
rownames(data.vecs)<-pairnames
astar<-solve((t(U)%*%U),(t(U)%*%A))
MSETotal<-cov(A)
U
astar<-solve((t(U)%*%U),(t(U)%*%A))
MSETotal<-cov(A)
s2aStar<-as.vector(MSETotal)*solve((t(U)%*%U))
s2aStar[1,1]
s2aStar<-as.vector(MSETotal)*qr.solve((t(U)%*%U))
s2aStar[1,1]
s2aStar<-as.vector(MSETotal)*chol2inv((t(U)%*%U))
s2aStar[1,1]
sdaStar<-t(diag(s2aStar)^(.5))
approxCFstar<-rbind(t(astar)-1.96%*%sdaStar, t(astar), t(astar)+1.96%*%sdaStar)
Pstar<-U%*%astar
Estar<-A-Pstar
MSEStar<-cov(matrix(Estar))
s2aStar<-as.vector(MSETotal)*qr.solve((t(U)%*%U))
sdaStar<-t(diag(s2aStar)^(.5))
approxCFstar<-rbind(t(astar)-1.96%*%sdaStar, t(astar), t(astar)+1.96%*%sdaStar)
Pstar<-U%*%astar
Estar<-A-Pstar
MSEStar<-cov(matrix(Estar))
V1 <- tree1
V2 <- tree2
#Calculate Regression Coefficents for the base (assuming strict brownian motion evolution, ds=1)
V1<-as.matrix(V1)
V2<-as.matrix(V2)
V<-kronecker(V2,V1)
invV <- chol2inv(V)
inV[1,1]
invV[1,1]
invV <- qr.solve(V)
invV[1,1]
invV <- solve(V)
invV[1,1]
tin <- Sys.time()
invV <- qr.solve(V)
tout <- Sys.time()
tin2 <- Sys.time()
invV <- solve(V)
tout2 <- Sys.time()
tout-tin
tout2-tin2
source("pblm.R") ## modified version of the code in the package 'picante'
tin <- Sys.time()
o <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=FALSE, maxit=1000, method="chol2inv")
tout <- Sys.time()
tin2 <- Sys.time()
o3 <- pblm(assocs=Y, tree1=ht, tree2=pt, bootstrap=FALSE, maxit=1000, method="solve")
tout2 <- Sys.time()
tout2-tin2
V1 <- tree1
V2 <- tree2
#Calculate Regression Coefficents for the base (assuming strict brownian motion evolution, ds=1)
V1<-as.matrix(V1)
V2<-as.matrix(V2)
V<-kronecker(V2,V1)
chol(V)
tin <- Sys.time()
invV1 <- chol2inv(chol(V))
tout <- Sys.time()
tin <- Sys.time()
invV2 <- qr.solve(V)
tout <- Sys.time()
tin <- Sys.time()
invV3 <- solve(V)
tout <- Sys.time()
library(MASS)
tin <- Sys.time()
invV4 <- ginv(V)
tout <- Sys.time()
tin <- Sys.time()
invV1 <- chol2inv(chol(V))
tout <- Sys.time()
tin2 <- Sys.time()
invV2 <- qr.solve(V)
tout2 <- Sys.time()
tin3 <- Sys.time()
invV3 <- solve(V)
tout3 <- Sys.time()
tin4 <- Sys.time()
invV4 <- ginv(V)
tout4 <- Sys.time()
tout4-tin4
tout3-tin3
tout2-tin2
tout1-tin1
tout-tin
abase<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
MSEBase<-(t(A-U%*%abase)%*%invV%*%(A-U%*%abase))/(nassocs-1)
s2abase<-as.vector(MSEBase)*chol2inv(chol(t(U)%*%invV%*%U))
invV[1,1]
invV1[1,1]
invV2[1,1]
invV3[1,1]
invV4[1,1]
o3
o3$signal.strength
o2$signal.strength
A<-as.matrix(as.vector(as.matrix(assocs)))
data.vecs<-A
#numbers of species and interactions
nassocs<-length(A)
nspp1<-dim(assocs)[1]
nspp2<-dim(assocs)[2]
sppnames1<-rownames(assocs)
sppnames2<-colnames(assocs)
#make names of species pairs
pairnames=NULL  # make a vector of pairwise comparison names
for (o in 1:(nspp2))
{
for (u in 1:nspp1)
{
pairnames<-c(pairnames,paste(sppnames2[o],sppnames1[u],sep="-"))
}
}
U<-rep(1,length(A))
data.vecs<-data.frame(A)
rownames(data.vecs)<-pairnames
astar<-solve((t(U)%*%U),(t(U)%*%A))
MSETotal<-cov(A)
s2aStar<-as.vector(MSETotal)*chol2inv(chol(t(U)%*%U))
sdaStar<-t(diag(s2aStar)^(.5))
approxCFstar<-rbind(t(astar)-1.96%*%sdaStar, t(astar), t(astar)+1.96%*%sdaStar)
Pstar<-U%*%astar
Estar<-A-Pstar
MSEStar<-cov(matrix(Estar))
V1 <- tree1
V2 <- tree2
#Calculate Regression Coefficents for the base (assuming strict brownian motion evolution, ds=1)
V1<-as.matrix(V1)
V2<-as.matrix(V2)
V<-kronecker(V2,V1)
invV <- chol2inv(chol(V))
abase<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
MSEBase<-(t(A-U%*%abase)%*%invV%*%(A-U%*%abase))/(nassocs-1)
s2abase<-as.vector(MSEBase)*chol2inv(chol(t(U)%*%invV%*%U))
sdabase<-t(diag(s2abase)^(.5))
approxCFbase<-rbind(t(abase)-1.96%*%sdabase, t(abase), t(abase)+1.96%*%sdabase)
Pbase<-t(t(U%*%abase)%*%invV)
Ebase<-A-Pbase
initV1<-V1
initV2<-V2
# tau = tau_i + tau_j where tau_i equals the node to tip distance
tau1<-matrix(diag(initV1),nspp1,nspp1) + matrix(diag(initV1),nspp1,nspp1)-2*initV1
tau2<-matrix(diag(initV2),nspp2,nspp2) + matrix(diag(initV2),nspp2,nspp2)-2*initV2
# The workhorse function to estimate ds
pegls<-function(parameters)
{
d1<-abs(parameters[1])
d2<-abs(parameters[2])
V1<-(d1^tau1)*(1-d1^(2*initV1))/(1-d1^2)
V2<-(d2^tau2)*(1-d2^(2*initV2))/(1-d2^2)
V1<-V1/det(V1)^(1/nspp1)   # model of coevolution
V2<-V2/det(V2)^(1/nspp2)
V<-kronecker(V2,V1)
if(method=="chol2inv") invV<- chol2inv(chol(V))
else if(method=="qr.solve") invV<- qr.solve(V)
else invV<- solve(V)
a<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
E<-(A-U%*%a)
#MSE
print(t(E)%*%invV%*%E/(nassocs-1))
return(t(E)%*%invV%*%E/(nassocs-1))
}
method="chol2inv"
# estimate d1 and d2 via Nelder-Mead method same as fminsearch in Matlab, by minimizing MSE
est<-optim(pstart,pegls,control=list(maxit=maxit))
est$par
MSEFull<-est$value
d1<-abs(est$par[1])
d2<-abs(est$par[2])
# Calculate EGLS coef w estimated ds
V1<-(d1^tau1)*(1-d1^(2*initV1))/(1-d1^2)
V2<-(d2^tau2)*(1-d2^(2*initV2))/(1-d2^2)
V1<-V1/det(V1)^(1/nspp1)   # model of coevolution
V2<-V2/det(V2)^(1/nspp2)
V<-kronecker(V2,V1)
if(method=="chol2inv") invV<-chol2inv(chol(V))
else if(method=="qr.solve") invV<-qr.solve(V)
else invV <- solve(V)
aFull<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
if(method=="chol2inv") s2aFull<-as.vector(MSEFull)*chol2inv(chol(t(U)%*%invV%*%U))
else if(method=="qr.solve") s2aFull<-as.vector(MSEFull)*qr.solve(t(U)%*%invV%*%U)
else s2aFull<-as.vector(MSEFull)*solve(t(U)%*%invV%*%U)
sdaFull<-t(diag(s2aFull)^(.5))
approxCFfull<-rbind(t(aFull)-1.96%*%sdaFull, t(aFull), t(aFull)+1.96%*%sdaFull)
Pfull<-t(t(U%*%aFull)%*%invV)
Efull<-A-Pfull
coefs<-cbind(approxCFfull,approxCFstar,approxCFbase)
rownames(coefs)<-c("approx lower CI 95%","estimate","approx upper CI 95%")
colnames(coefs)<-c(paste("full",c("intercept",colnames(U)[-1]),sep="-"),paste("star",c("intercept",colnames(U)[-1]),sep="-"),paste("base",c("intercept",colnames(U)[-1]),sep="-"))
coefs<-t(coefs)
CI.boot<-NULL
MSEs<-cbind(data.frame(MSETotal),data.frame(MSEFull), data.frame(MSEStar), data.frame(MSEBase))
residuals<-cbind(data.frame(Efull),data.frame(Estar),data.frame(Ebase))
predicted<-cbind(data.frame(Pfull),data.frame(Pstar),data.frame(Pbase))
rownames(residuals)<-pairnames
rownames(predicted)<-pairnames
colnames(predicted)<-c("full","star","base")
colnames(residuals)<-c("full","star","base")
phylocovs=list(V1=V1,V2=V2)
Vtrue<-V
Atrue<-A
atrue<-aFull
dtrue<-c(d1,d2)
ehold<-eigen(Vtrue,symmetric=TRUE)
L<-ehold$vectors[,nassocs:1]    #A or L
G<-sort(ehold$values)      #D
iG<-diag(G^-.5)    #iD
TT<-iG%*%t(L)
Y<-TT%*%Atrue
Z<-TT%*%U
res<-(Y-Z%*%atrue)	# residuals in orthogonalized space
invT<- chol2inv(chol(TT))
invT <- qr.solve(TT)
nreps = 4
ncores= 4
nreps = 4
nreps = 3
ncores= 3
bootlist=NULL
bootlist <- mclapply(1:nreps,
function(i) {
randindex<-sample(1:nassocs,replace=TRUE)	# vector of random indices
#randindex=1:nassocs					# retain order
YY<-Z%*%atrue+res[randindex]	# create new values of Y with random residuals
A<-invT%*%YY	# back-transformed data
pstart<-dtrue+c(0,.1)
estRand<-optim(pstart,pegls,control=list(maxit=maxit))
MSEFullrand<-estRand$value
d1rand<-abs(estRand$par[1])
d2rand<-abs(estRand$par[2])
# Calculate EGLS coef w estimated ds
V1<-(d1rand^tau1)*(1-d1rand^(2*initV1))/(1-d1rand^2)
V2<-(d2rand^tau2)*(1-d2rand^(2*initV2))/(1-d2rand^2)
V1<-V1/det(V1)^(1/nspp1)   # model of coevolution
V2<-V2/det(V2)^(1/nspp2)
V<-kronecker(V2,V1)
invV<-chol2inv(chol(V))
arand<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
rbind(bootlist,c(d1rand, d2rand, t(arand)))
},
mc.cores=ncores)
library(parallel)
bootlist <- mclapply(1:nreps,
function(i) {
randindex<-sample(1:nassocs,replace=TRUE)	# vector of random indices
#randindex=1:nassocs					# retain order
YY<-Z%*%atrue+res[randindex]	# create new values of Y with random residuals
A<-invT%*%YY	# back-transformed data
pstart<-dtrue+c(0,.1)
estRand<-optim(pstart,pegls,control=list(maxit=maxit))
MSEFullrand<-estRand$value
d1rand<-abs(estRand$par[1])
d2rand<-abs(estRand$par[2])
# Calculate EGLS coef w estimated ds
V1<-(d1rand^tau1)*(1-d1rand^(2*initV1))/(1-d1rand^2)
V2<-(d2rand^tau2)*(1-d2rand^(2*initV2))/(1-d2rand^2)
V1<-V1/det(V1)^(1/nspp1)   # model of coevolution
V2<-V2/det(V2)^(1/nspp2)
V<-kronecker(V2,V1)
invV<-chol2inv(chol(V))
arand<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
rbind(bootlist,c(d1rand, d2rand, t(arand)))
},
mc.cores=ncores)
bootlist
randindex<-sample(1:nassocs,replace=TRUE)
YY<-Z%*%atrue+res[randindex]	# create new values of Y with random residuals
A<-invT%*%YY	# back-transformed data
pstart<-dtrue+c(0,.1)
YY[1,1]
randindex<-sample(1:nassocs,replace=TRUE)	# vector of random indices
#randindex=1:nassocs					# retain order
YY<-Z%*%atrue+res[randindex]	# create new values of Y with random residuals
A<-invT%*%YY	# back-transformed data
pstart<-dtrue+c(0,.1)
YY[1,1]
estRand<-optim(pstart,pegls,control=list(maxit=maxit))
estRand$par
library(MCMCglmm)
library(gdata)
library(igraph)
library(phytools)
library(tidyverse)
gmpd_mam_tree <- read.tree("mammal_tree_clean.tre")
gmpd_para_tree <- read.tree("helminth_tree_clean.tre")
###############################
##  Format the GMPD Data     ##
###############################
data <- read.csv("GMPD_clean.csv")
## create a new data.frame with all possible host-parasite combinations
expand.grid(Host.species=(data$HostCorrectedName %>% unique),
Parasite.species=(data$ParasiteCorrectedName %>% unique)) -> ndata
## ncount = the number of times that each association occurs in data
## presence = incidence data (0/1 if the association occurs or not)
## nhosts.sampled = the number of times each host occurs in the GMPD
## nparas.sampled = the number of times each parasite occurs in the GMPD
mutate(ndata,
ncount=left_join(ndata, data %>% count(HostCorrectedName,ParasiteCorrectedName),
by=c("Host.species"="HostCorrectedName","Parasite.species"="ParasiteCorrectedName"))$n,
presence=ifelse(is.na(ncount),0,1),
nhosts.sampled=left_join(ndata, data %>% count(HostCorrectedName),
by=c("Host.species"="HostCorrectedName"))$n,
nparas.sampled=left_join(ndata, data %>% count(ParasiteCorrectedName),
by=c("Parasite.species"="ParasiteCorrectedName"))$n) -> gmpd_ndata
##################################
##      Primate-only data       ##
##################################
pdata <- subset(data, HostOrder=="Primates")
## prune the phylogenies to include only this data
primate_tree <- keep.tip(gmpd_mam_tree, gsub(" ","_",unique(pdata$HostCorrectedName)))
primate_para_tree <- keep.tip(gmpd_para_tree, gsub(" ","_",unique(pdata$ParasiteCorrectedName)))
## create a new data.frame with all possible host-parasite combinations
expand.grid(Host.species=(pdata$HostCorrectedName %>% unique),
Parasite.species=(pdata$ParasiteCorrectedName %>% unique)) -> primate_ndata
mutate(primate_ndata,
ncount=left_join(primate_ndata, pdata %>% count(HostCorrectedName,ParasiteCorrectedName),
by=c("Host.species"="HostCorrectedName","Parasite.species"="ParasiteCorrectedName"))$n,
presence=ifelse(is.na(ncount),0,1),
nhosts.sampled=left_join(primate_ndata, pdata %>% count(HostCorrectedName),
by=c("Host.species"="HostCorrectedName"))$n,
nparas.sampled=left_join(primate_ndata, pdata %>% count(ParasiteCorrectedName),
by=c("Parasite.species"="ParasiteCorrectedName"))$n) -> primate_ndata
primate_ndata$Host.species <- as.factor(as.character(primate_ndata$Host.species))
primate_ndata$Parasite.species <- as.factor(as.character(primate_ndata$Parasite.species))
##############################
##      Nearctic data       ##
##############################
## Load the trees
nearctic_mam_tree <- read.tree("nearctic_mammal_tree_clean.tre")
nearctic_para_tree <- read.tree("nearctic_helminth_tree_clean.tre")
## Load the data
nearctic_data <- read.csv("nearctic_data_clean.csv")
expand.grid(Host.species=(nearctic_data$Host %>% unique),
Parasite.species=(nearctic_data$Parasite %>% unique)) -> nearctic_ndata
mutate(nearctic_ndata,
ncount=left_join(nearctic_ndata, nearctic_data %>% count(Host,Parasite),
by=c("Host.species"="Host","Parasite.species"="Parasite"))$n,
presence=ifelse(is.na(ncount),0,1),
nhosts.sampled=left_join(nearctic_ndata, nearctic_data %>% count(Host),
by=c("Host.species"="Host"))$n,
nparas.sampled=left_join(nearctic_ndata, nearctic_data %>% count(Parasite),
by=c("Parasite.species"="Parasite"))$n) -> nearctic_ndata
source("pblm.R") ## modified version of the code in the package 'picante'
ht<-vcv(primate_tree, corr=T)
pt<-vcv(primate_para_tree, corr=T)
Y<-table(primate_ndata$Host.species, primate_ndata$Parasite.species, primate_ndata$presence)[,,2]>0
## change names to match the phylogeny
rownames(Y) <- gsub(" ", "_", rownames(Y))
colnames(Y) <- gsub(" ", "_", colnames(Y))
## reorder A matrices so match row/columns of Y
hi<-match(rownames(Y), rownames(ht))
pi<-match(colnames(Y), rownames(pt))
ht<-ht[hi,hi]
pt<-pt[pi,pi]
tin <- Sys.time()
o <- pblm(assocs=Y, tree1=ht, tree2=pt, maxit=1000, method="chol2inv")
tout <- Sys.time()
tout-tin
o$signal.strength
d1 <- o$signal.strength[1,2]
d2 <- o$signal.strength[2,2]
A<-as.matrix(as.vector(as.matrix(Y)))
nassocs<-length(A)
nspp1<-dim(Y)[1]
nspp2<-dim(Y)[2]
U<-rep(1,length(A))
initV1<-as.matrix(ht)
initV2<-as.matrix(pt)
# tau = tau_i + tau_j where tau_i equals the node to tip distance
tau1<-matrix(diag(initV1),nspp1,nspp1) + matrix(diag(initV1),nspp1,nspp1)-2*initV1
tau2<-matrix(diag(initV2),nspp2,nspp2) + matrix(diag(initV2),nspp2,nspp2)-2*initV2
V1<-(d1^tau1)*(1-d1^(2*initV1))/(1-d1^2)
V2<-(d2^tau2)*(1-d2^(2*initV2))/(1-d2^2)
V1<-V1/det(V1)^(1/nspp1)   # model of coevolution
V2<-V2/det(V2)^(1/nspp2)
V<-kronecker(V2,V1)
invV<-chol2inv(chol(V))
aFull<-solve((t(U)%*%invV%*%U),((t(U)%*%invV%*%A)))   #NOTE: Ives in his Matlab code uses a Left matrix division
Vtrue<-V
Atrue<-A
atrue<-aFull
dtrue<-c(d1,d2)
ehold<-eigen(Vtrue,symmetric=TRUE)
L<-ehold$vectors[,nassocs:1]    #A or L
G<-sort(ehold$values)      #D
iG<-diag(G^-.5)    #iD
# Construct Y = TT*A so that
# E{(Y-b)*(Y-b)'} = E{(TT*A-b)*(TT*A-b)'}
#				  = T*V*T'
#				  = I
TT<-iG%*%t(L)
Y<-TT%*%Atrue
Z<-TT%*%U
res<-(Y-Z%*%atrue)	# residuals in orthogonalized space
invT <- qr.solve(TT)
Aboot <- vector(mode='list', length=100)
for (i in 1:length(Aboot)) {
randindex<-sample(1:nassocs,replace=TRUE)	# vector of random indices
#randindex=1:nassocs					# retain order
YY<-Z%*%atrue+res[randindex]	# create new values of Y with random residuals
Aboot[[i]]<-invT%*%YY	# back-transformed data
}
source("pblm_bootstrap.R")
tin <- Sys.time()
ob <- pblm_boot(Aboot[[1]], ht, pt, d1, d2)
tout <- Sys.time()
tout-tin
saveRDS(o, file="IvesGodfray_full_primate.RDS")
ob
